```json
{
    "section_title": "Lecture 14: Inheritance, Polymorphism, and Virtual Functions",
    "section_description": "This lecture covers fundamental concepts of inheritance, including member access with `protected`, constructor chaining, the problem of object slicing, and the use of `virtual` functions to achieve polymorphism (dynamic dispatch). It also discusses virtual destructors and `final` classes.",
    "slides": [
        {
            "title": "Lecture 14: Introduction",
            "slide_markdown": "## Lecture 14: Inheritance, Polymorphism, and Virtual Functions\n\n*   **Inheritance**: Building new classes from existing ones.\n*   **Polymorphism**: Treating objects of different classes uniformly.\n*   **Virtual Functions**: The mechanism for runtime polymorphism in C++.\n\n**Today's Key Topics:**\n1.  Introduction to Inheritance (Base & Derived Classes)\n2.  `protected` Member Access\n3.  Slicing and Static Dispatch\n4.  `virtual` Functions & Dynamic Dispatch\n5.  Virtual Destructors\n6.  `final` Classes & Abstract Classes (Pure Virtual Methods)",
            "transcript": "Welcome to Lecture 14. Today, we'll explore some powerful object-oriented programming concepts in C++. We'll start with inheritance, which allows us to create new classes based on existing ones, promoting code reuse and establishing 'is-a' relationships. Then, we'll delve into polymorphism, the ability for objects of different types to be treated through a common interface. The key C++ feature enabling this is virtual functions, which facilitate dynamic dispatch, meaning the correct function to call is decided at runtime. We'll cover how to control member access for derived classes using 'protected', understand potential pitfalls like slicing and static dispatch, and then see how virtual functions solve these. We'll also discuss the critical role of virtual destructors for correct memory management in inheritance hierarchies, and finally, touch upon 'final' classes and abstract classes defined by pure virtual methods.",
            "subtopic_id": 0,
            "subtopic_title": "Section Introduction"
        },
        {
            "title": "Subtopic 1: Introduction to Inheritance - Basic Concepts",
            "slide_markdown": "## Subtopic 1: Introduction to Inheritance (Book, Text, Comic)\n\n**What is Inheritance?**\n*   A mechanism to create new classes (derived/child/subclasses) from existing classes (base/parent/superclasses).\n*   Establishes an \"is-a\" relationship (e.g., a `Text` book *is a* `Book`).\n*   Promotes code reuse.\n\n**Example:**\n```cpp\n// Base Class\nclass Book {\n    std::string author, title;\n    int length;\npublic:\n    Book(std::string auth, std::string ttl, int len);\n    void displayBaseInfo() const;\n};\n\n// Derived Class\nclass Text : public Book {\n    std::string topic;\npublic:\n    Text(std::string auth, std::string ttl, int len, std::string top);\n    void displayTopic() const;\n};\n```",
            "transcript": "Let's begin with the core idea of inheritance. Inheritance is a fundamental OOP principle where you can define a new class, called a derived class or child class, based on an existing class, known as a base class or parent class. This creates an 'is-a' relationship. For instance, if we have a general 'Book' class, we can derive a more specific 'Text' book class from it. A 'Text' book 'is a' type of 'Book'. This is powerful because it allows the derived class to inherit properties and behaviors from the base class, promoting code reuse. In our example, 'Book' is the base class with author, title, and length. 'Text' is derived from 'Book' and adds a specific 'topic' field. The 'public Book' part in the 'Text' class declaration signifies public inheritance, meaning public members of 'Book' remain public in 'Text', and protected members of 'Book' become protected in 'Text'.",
            "subtopic_id": 1,
            "subtopic_title": "Introduction to Inheritance (Book, Text, Comic)"
        },
        {
            "title": "Subtopic 1: What's Inherited & Member Access",
            "slide_markdown": "## Subtopic 1: What's Inherited & Member Access\n\n**What Derived Classes Inherit:**\n*   Fields (data members) from the base class.\n*   Methods (member functions) from the base class.\n    *   `Text` and `Comic` (another derived class) would inherit `author`, `title`, `length`, and methods like `displayBaseInfo()` from `Book`.\n\n**Member Accessibility:**\n*   **`public` members of Base:** Accessible by anyone (base, derived, external code).\n*   **`protected` members of Base:** Accessible by the base class and its derived classes (more on this in Subtopic 2).\n*   **`private` members of Base:** Accessible *only* by the base class itself. **Derived classes cannot directly access private members of the base class.**\n\n```cpp\n// In Book.cpp\nBook::Book(std::string auth, std::string ttl, int len)\n    : author(auth), title(ttl), length(len) {}\n\n// In Text.cpp - if author, title, length were private in Book:\n// Text::someMethod() {\n//     author = \"new author\"; // ERROR! Cannot access private members of Book\n// }\n```",
            "transcript": "So, what exactly does a derived class get from its base class? It inherits the data members (fields) and member functions (methods). In our 'Book' and 'Text' example, the 'Text' class automatically has the 'author', 'title', and 'length' fields, as well as any public or protected methods defined in 'Book'.\n\nNow, let's talk about member accessibility. Public members of the base class are accessible everywhere. Protected members, which we'll discuss soon, are accessible within the base class and its derived classes. Crucially, private members of the base class are *only* accessible by the base class itself. This means that even though 'Text' inherits from 'Book', 'Text's methods cannot directly access 'Book's private fields like 'author', 'title', or 'length' if they were declared private in 'Book'. This encapsulation is a key principle of OOP, ensuring that the internal state of the base class is managed by its own methods.",
            "subtopic_id": 1,
            "subtopic_title": "Introduction to Inheritance (Book, Text, Comic)"
        },
        {
            "title": "Subtopic 1: Object Construction Order",
            "slide_markdown": "## Subtopic 1: Object Construction Order\n\nWhen a derived class object is created, construction happens in a specific order:\n\n1.  **Base Class Part Construction:**\n    *   The appropriate base class constructor is called first. This initializes the inherited members.\n2.  **Derived Class Member Initialization:**\n    *   The derived class's own data members are initialized (often via the Member Initialization List - MIL).\n3.  **Derived Class Constructor Body Execution:**\n    *   The body of the derived class's constructor executes.\n\n**Example Breakdown for `Text t(...);`**\n1.  `Book`'s constructor runs (e.g., `Book(auth, ttl, len)`).\n2.  `Text`'s member `topic` is initialized (e.g., `topic_` gets value of `top`).\n3.  The body of `Text`'s constructor (if any) executes.",
            "transcript": "Understanding the order of construction is vital when working with inheritance. When you create an object of a derived class, say 'Text t', the process isn't as simple as just running the 'Text' constructor. First, the base class part of the object must be constructed. This means a constructor from the 'Book' class is called to initialize the 'author', 'title', and 'length' members. After the 'Book' part is fully constructed, the 'Text' class's own data members are initialized â€“ in our case, the 'topic' field. Finally, the body of the 'Text' class's constructor is executed. This layered construction ensures that all parts of the object are properly initialized, starting from the most general (base) to the most specific (derived).",
            "subtopic_id": 1,
            "subtopic_title": "Introduction to Inheritance (Book, Text, Comic)"
        },
        {
            "title": "Subtopic 1: Initializing Base Class Members (MIL)",
            "slide_markdown": "## Subtopic 1: Initializing Base Class Members (MIL)\n\nHow does the derived class ensure the base class part is correctly initialized, especially if the base needs specific constructor arguments?\n\n*   **Using the Member Initialization List (MIL):** The derived class constructor *must* call an appropriate base class constructor in its MIL.\n\n```cpp\n// Text.h or Text.cpp\nclass Text : public Book {\n    std::string topic_;\npublic:\n    Text(std::string author, std::string title, int length, std::string topic)\n        : Book(author, title, length), // Explicitly call Book's constructor\n          topic_{topic} {              // Initialize Text's own member\n        // Constructor body for Text\n        // Base part (Book) is already constructed here.\n    }\n};\n```\n*   If the base class constructor is not explicitly called in the MIL, the compiler will attempt to call the base class's default (zero-argument) constructor. If no default constructor exists and none is called, it's a compile-time error.",
            "transcript": "We've seen that the base class constructor runs first. But how do we control which base class constructor is called, especially if the base class needs arguments for its initialization? This is done using the Member Initialization List, or MIL, in the derived class's constructor. In the 'Text' constructor, you see ': Book(author, title, length)'. This part explicitly tells the compiler to call the 'Book' constructor that takes an author, title, and length. This call happens *before* the 'Text' constructor body executes. After the base class constructor call, we initialize the 'Text' class's own members, like 'topic_'.\n\nIt's important to note: if you don't explicitly call a base class constructor in the MIL, the compiler will try to call the base class's default constructor (one that takes no arguments). If the base class doesn't have a default constructor, and you haven't explicitly called another one, your code won't compile. So, always be mindful of how the base class part of your derived object is being initialized.",
            "subtopic_id": 1,
            "subtopic_title": "Introduction to Inheritance (Book, Text, Comic)"
        },
        {
            "title": "Subtopic 1: Summary of Inheritance Introduction",
            "slide_markdown": "## Subtopic 1: Summary\n\n*   **Inheritance** allows creating specialized classes (`Text`, `Comic`) from a general one (`Book`), fostering an \"is-a\" relationship and code reuse.\n*   Derived classes inherit fields and methods, but **cannot directly access `private` members** of the base class.\n*   **Object Construction Order:**\n    1.  Base class constructor.\n    2.  Derived class member initialization (MIL).\n    3.  Derived class constructor body.\n*   The derived class constructor **must call a base class constructor in its MIL** to initialize the base part, especially if constructor arguments are needed by the base.",
            "transcript": "To summarize our introduction to inheritance: Inheritance is a powerful tool for creating specialized classes from more general ones, like deriving 'Text' and 'Comic' from a 'Book'. This establishes an 'is-a' relationship and helps in reusing code. Derived classes inherit the fields and methods of their base class. However, a crucial point of encapsulation is that derived classes cannot directly access the private members of their base class. When an object of a derived class is created, the construction follows a strict order: first, the base class constructor is called, then the derived class's own members are initialized through its Member Initialization List, and finally, the body of the derived class's constructor executes. It's essential for the derived class constructor to explicitly call an appropriate base class constructor in its MIL to ensure the base part of the object is correctly initialized.",
            "subtopic_id": 1,
            "subtopic_title": "Introduction to Inheritance (Book, Text, Comic)"
        },
        {
            "title": "Subtopic 2: `protected` Member Access - Introduction",
            "slide_markdown": "## Subtopic 2: `protected` Member Access\n\n**The Dilemma:**\n*   `private` members: Secure, but inaccessible to derived classes.\n*   `public` members: Accessible to derived classes, but also to everyone (breaks encapsulation for internal state).\n\n**The `protected` Access Specifier:**\n*   `protected` members of a base class are:\n    *   Accessible within the base class itself.\n    *   Accessible within any class derived from it.\n    *   **Not accessible** by unrelated, external code (like `public` members would be).\n\n```cpp\nclass Book {\nprotected:\n    std::string author_;\n    std::string title_;\n    int length_;\npublic:\n    Book(std::string a, std::string t, int l);\n};\n```",
            "transcript": "Now let's discuss `protected` member access. We've seen that private members of a base class are off-limits to derived classes, which is good for encapsulation. Public members, on the other hand, are accessible to derived classes, but they are also accessible to any external code, which might not be desirable for internal state management. This presents a dilemma: how can we allow derived classes some privileged access without making everything public?\n\nThe `protected` access specifier provides a solution. Members declared as `protected` in a base class can be accessed by methods of the base class itself and by methods of any class derived from it. However, unlike public members, protected members are not accessible by unrelated, external code. This offers a middle ground between the strictness of private and the openness of public.",
            "subtopic_id": 2,
            "subtopic_title": "`protected` Member Access"
        },
        {
            "title": "Subtopic 2: `protected` Access in Derived Classes",
            "slide_markdown": "## Subtopic 2: `protected` Access in Derived Classes\n\nWith `protected` base members, derived classes can access them directly:\n\n```cpp\nclass Text : public Book {\n    std::string topic_;\npublic:\n    Text(std::string a, std::string t, int l, std::string top)\n        : Book(a, t, l), topic_(top) {}\n\n    void printBookDetails() {\n        // Can directly access protected members from Book\n        std::cout << \"Title: \" << title_ << std::endl;\n        std::cout << \"Author: \" << author_ << std::endl;\n    }\n};\n\n// External code:\n// Book myBook(...);\n// myBook.author_ = \"New Author\"; // ERROR! author_ is protected, not public.\n```",
            "transcript": "Let's see how `protected` members are used in a derived class. If 'author_', 'title_', and 'length_' in the 'Book' class are declared as `protected`, then methods within the 'Text' class, which derives from 'Book', can directly access these members. For example, a 'printBookDetails' method in 'Text' could directly use 'title_' and 'author_'.\n\nHowever, if you try to access these protected members from external code, outside the 'Book' or 'Text' classes (or any other derived class), you'll get a compile-time error. This is because, from an external perspective, protected members behave like private members, thus maintaining a level of encapsulation against the outside world while allowing privileged access to the inheritance hierarchy.",
            "subtopic_id": 2,
            "subtopic_title": "`protected` Member Access"
        },
        {
            "title": "Subtopic 2: The Risk of Direct `protected` Access",
            "slide_markdown": "## Subtopic 2: The Risk of Direct `protected` Access\n\nAllowing derived classes to *directly modify* `protected` data members can be risky:\n*   **Breaking Base Class Invariants:** The base class might have rules (invariants) about its data that the derived class could unknowingly violate.\n    *   Example: `Book` might expect `length_` to always be positive. A `Text` method could mistakenly set `length_ = -10;`.\n*   **Increased Coupling:** Derived classes become more tightly coupled to the specific implementation details of the base class.\n\n```cpp\n// In Text class\nvoid potentiallyProblematicMethod() {\n    // Direct modification of a protected member from Book\n    length_ = 0; // What if Book expects length_ > 0?\n    author_ = \"\"; // What if Book expects a non-empty author?\n}\n```",
            "transcript": "While `protected` access allows derived classes to interact more closely with the base class, giving them direct write access to protected data members comes with risks. The primary concern is that a derived class might inadvertently break invariants of the base class. An invariant is a condition or rule about the data that the base class expects to always hold true. For example, the 'Book' class might assume that 'length_' is always a positive number. If a method in the 'Text' class directly modifies 'length_' and sets it to a negative value, it breaks this invariant, potentially leading to incorrect behavior in 'Book's methods.\n\nFurthermore, direct access to protected data members increases the coupling between the base and derived classes. The derived class becomes dependent on the exact internal representation of the base class, making the system more brittle and harder to change.",
            "subtopic_id": 2,
            "subtopic_title": "`protected` Member Access"
        },
        {
            "title": "Subtopic 2: Better Approach - `private` Fields, `protected` Methods",
            "slide_markdown": "## Subtopic 2: Better Approach - `private` Fields, `protected` Methods\n\nA more robust design:\n1.  Keep base class data members **`private`**.\n2.  Provide **`protected` accessor and mutator methods** for derived classes to use.\n\n```cpp\nclass Book {\nprivate:\n    std::string author_;\n    std::string title_;\n    int length_;\nprotected:\n    // Protected mutator for derived classes\n    void setLength(int newLength) {\n        if (newLength > 0) length_ = newLength;\n        // else handle error or ignore\n    }\n    // Protected accessor\n    int getLength() const { return length_; }\n    // Similar for author and title\npublic:\n    Book(std::string a, std::string t, int l);\n};\n```\n**Benefits:**\n*   Base class maintains control over its invariants.\n*   Reduces coupling; derived classes interact through a defined interface.",
            "transcript": "A better and more robust approach to managing access for derived classes is to keep the base class's data members private and provide protected accessor (getter) and mutator (setter) methods. This way, the base class retains full control over its internal state and can enforce its invariants. For example, in the 'Book' class, 'author_', 'title_', and 'length_' would be private. Then, we could provide a protected 'setLength' method. This method can include validation logic, such as ensuring 'newLength' is positive before updating the private 'length_' member. Derived classes would then use these protected methods instead of directly accessing the data.\n\nThis design has significant benefits: the base class can guarantee its invariants are maintained, and the coupling between base and derived classes is reduced because derived classes interact through a well-defined (protected) interface rather than directly manipulating internal data.",
            "subtopic_id": 2,
            "subtopic_title": "`protected` Member Access"
        },
        {
            "title": "Subtopic 2: Summary of `protected` Access",
            "slide_markdown": "## Subtopic 2: Summary\n\n*   `protected` members are accessible within the **class itself and its derived classes**, but not externally.\n*   Directly exposing `protected` data members to derived classes can lead to **broken invariants** and **increased coupling**.\n*   A better practice is to keep base class data members **`private`** and provide **`protected` accessor/mutator methods**.\n    *   This allows the base class to maintain control and enforce its rules, while still providing necessary access to derived classes.",
            "transcript": "To summarize `protected` member access: The `protected` keyword allows members of a base class to be accessed by the class itself and any classes derived from it, while still preventing access from unrelated external code. However, directly exposing data members as protected, especially for modification, can be risky. It can lead to derived classes inadvertently breaking the base class's internal rules or invariants, and it increases the coupling between the classes, making the system harder to maintain. A more robust and recommended approach is to keep the base class data members private and, if necessary, provide protected accessor and mutator methods. This strategy ensures that the base class maintains control over its state and can enforce its invariants, offering a safer and more flexible interface for its derived classes.",
            "subtopic_id": 2,
            "subtopic_title": "`protected` Member Access"
        },
        {
            "title": "Subtopic 3: Polymorphism Issue - Slicing",
            "slide_markdown": "## Subtopic 3: Polymorphism Issue: Slicing and Static Dispatch\n\n**Slicing: Losing Derived-Specific Parts**\n*   Occurs when a derived class object is assigned or copied *by value* to a base class object.\n*   The base class object only has space for base class members. Derived-specific members are \"sliced off.\"\n\n```cpp\nclass Book { /* author, title, length */ };\nclass Comic : public Book {\n    std::string hero_;\npublic:\n    Comic(std::string a, std::string t, int l, std::string h)\n        : Book(a,t,l), hero_(h) {}\n    // ...\n};\n\nComic myComic(\"Writer\", \"SuperComic\", 50, \"The Hero\");\nBook bookCopy = myComic; // Slicing!\n// bookCopy contains author, title, length from myComic.\n// bookCopy does NOT contain hero_.\n// The 'hero_' field is chopped off.\n```",
            "transcript": "Let's move on to a common issue in polymorphism: slicing. Slicing happens when you assign or copy a derived class object to a base class object by value. Think about it: the base class object only has enough memory allocated for the members defined in the base class. If you try to stuff a larger derived object (which includes base members plus its own specific members) into a base class variable, there's no room for those extra derived-specific parts. So, those parts are simply lost, or 'sliced off.'\n\nConsider our 'Comic' class, which inherits from 'Book' and adds a 'hero_' field. If you have a 'Comic' object 'myComic' and then write 'Book bookCopy = myComic;', 'bookCopy' will get the 'author', 'title', and 'length' from 'myComic'. However, the 'hero_' field, which is specific to 'Comic', will be lost because 'bookCopy', being a 'Book' object, doesn't have a place to store it. This is slicing.",
            "subtopic_id": 3,
            "subtopic_title": "Polymorphism Issue: Slicing and Static Dispatch"
        },
        {
            "title": "Subtopic 3: Static Dispatch with Non-Virtual Methods",
            "slide_markdown": "## Subtopic 3: Static Dispatch with Non-Virtual Methods\n\nWhen calling methods via base class pointers or references:\n*   If the method is **non-virtual**, the compiler chooses the method version based on the **static type** of the pointer/reference (i.e., the type it was declared as).\n*   This is called **static dispatch** or early binding (resolved at compile time).\n\n```cpp\n// Assume Book and Comic both have an isHeavy() method.\n// Book::isHeavy() { return length > 200; }\n// Comic::isHeavy() { return length < 30; } // Different logic!\n\nComic myComic(\"Writer\", \"SuperComic\", 25, \"The Hero\"); // 25 pages\nBook* bookPtr = &myComic;\n\n// If isHeavy() is NOT virtual in Book:\nstd::cout << myComic.isHeavy(); // Calls Comic::isHeavy() -> true (25 < 30)\nstd::cout << bookPtr->isHeavy(); // Calls Book::isHeavy() -> false (25 not > 200)\n```\n*   `bookPtr` *points to* a `Comic`, but its *declared type* is `Book*`.\n*   The call `bookPtr->isHeavy()` resolves to `Book::isHeavy()`.",
            "transcript": "Another important concept is static dispatch. This occurs when you call a non-virtual method through a base class pointer or reference that actually points to a derived class object. In this scenario, the compiler decides which version of the method to call based on the declared type of the pointer or reference, not on the actual type of the object it points to at runtime. This decision is made at compile time, hence 'static' dispatch or early binding.\n\nImagine both 'Book' and 'Comic' have an 'isHeavy' method, but with different logic. Say, a book is heavy if it's over 200 pages, but a comic is heavy if it's under 30 pages (just for example). If 'isHeavy' is not declared virtual in 'Book', and you have a 'Book' pointer 'bookPtr' pointing to a 'Comic' object, calling 'bookPtr->isHeavy()' will execute 'Book::isHeavy()'. Even though 'bookPtr' is pointing to a 'Comic', the compiler only sees 'bookPtr' as a 'Book*', so it calls the 'Book' version. This means 'myComic.isHeavy()' might give one result (using 'Comic's logic), while 'bookPtr->isHeavy()' gives a different result (using 'Book's logic), which is often not what we want for polymorphic behavior.",
            "subtopic_id": 3,
            "subtopic_title": "Polymorphism Issue: Slicing and Static Dispatch"
        },
        {
            "title": "Subtopic 3: Consequences of Slicing & Static Dispatch",
            "slide_markdown": "## Subtopic 3: Consequences of Slicing & Static Dispatch\n\n**Slicing:**\n*   Loss of data and potentially type information.\n*   Can lead to unexpected behavior if you expect derived class state to be preserved.\n\n**Static Dispatch (for non-virtual methods):**\n*   Prevents true polymorphic behavior where the object's actual type determines the method executed.\n*   The base class version of the method is always called through base pointers/references, regardless of the object's runtime type.\n\n**Why this is often not desired:**\nWe usually want the behavior to match the *actual type* of the object, not just the type of the pointer/reference used to access it. This is the essence of polymorphism.",
            "transcript": "Slicing and static dispatch for non-virtual methods can lead to behaviors that are often not what we intend when designing polymorphic systems. Slicing results in the loss of derived-specific data and, in a sense, the 'type identity' of the object when it's copied into a base class variable. You might expect the derived object's full state to be considered, but only the base part survives.\n\nStatic dispatch, for non-virtual methods, means that even if a base class pointer is pointing to a derived object with its own specialized version of a method, calling that method through the base pointer will still execute the base class's version. This undermines the core idea of polymorphism, where we want the specific behavior of the actual object's type to be invoked, regardless of how we are referring to it (e.g., through a base class pointer). We want the system to adapt to the object's true nature at runtime.",
            "subtopic_id": 3,
            "subtopic_title": "Polymorphism Issue: Slicing and Static Dispatch"
        },
        {
            "title": "Subtopic 3: Summary of Slicing and Static Dispatch",
            "slide_markdown": "## Subtopic 3: Summary\n\n*   **Slicing** occurs when a derived object is assigned/copied to a base class object, resulting in the loss of derived-specific members and behavior tied to them.\n*   **Static Dispatch** (or early binding) happens for **non-virtual methods**: the method call is resolved at compile time based on the static type of the pointer or reference, not the actual (dynamic) type of the object.\n*   These behaviors prevent true runtime polymorphism, where the action performed depends on the object's actual type.\n*   To achieve runtime polymorphism, we need **virtual functions**.",
            "transcript": "In summary of this subtopic: Slicing is the loss of derived-specific parts when a derived object is copied into a base class object. This happens because the base object only has space for base class members. Static dispatch, also known as early binding, is the mechanism used for non-virtual methods. When you call a non-virtual method through a base class pointer or reference, the compiler decides at compile time which version of the method to execute, based solely on the declared type of that pointer or reference, not the actual dynamic type of the object it might be pointing to. Both slicing and static dispatch for non-virtual methods limit our ability to achieve true runtime polymorphism, where the behavior adapts to the specific type of the object at runtime. The solution to enable this dynamic behavior lies in virtual functions, which we'll explore next.",
            "subtopic_id": 3,
            "subtopic_title": "Polymorphism Issue: Slicing and Static Dispatch"
        },
        {
            "title": "Subtopic 4: `virtual` Member Functions for Dynamic Dispatch",
            "slide_markdown": "## Subtopic 4: `virtual` Member Functions for Dynamic Dispatch\n\n**Achieving Runtime Polymorphism:**\n*   Declare the method as **`virtual`** in the base class.\n*   Derived classes can then **`override`** this virtual method to provide their specific implementation.\n*   When called via a base class pointer or reference, the version corresponding to the object's **actual (dynamic) type** is executed at runtime.\n*   This is called **dynamic dispatch** or late binding.\n\n```cpp\nclass Book {\npublic:\n    // ... fields and constructor ...\n    virtual bool isHeavy() const { return length_ > 200; } // Declared virtual\n    virtual ~Book() {} // Good practice: virtual destructor\nprotected:\n    int length_;\n};\n```",
            "transcript": "To overcome the limitations of static dispatch and achieve true runtime polymorphism, C++ uses virtual member functions. When you declare a method as `virtual` in a base class, you are signaling that derived classes might provide their own versions of this method. Derived classes can then `override` this virtual method with their specific implementation. The magic happens when you call this virtual method through a base class pointer or reference: the program, at runtime, determines the actual type of the object being pointed to and calls the version of the method appropriate for that specific type. This is known as dynamic dispatch or late binding, as the decision of which function to call is deferred until runtime. Notice in the example, `isHeavy()` in the `Book` class is now declared `virtual`. Also, it's good practice to make the destructor virtual if a class is intended to be a base class, which we'll discuss in more detail later.",
            "subtopic_id": 4,
            "subtopic_title": "`virtual` Member Functions for Dynamic Dispatch"
        },
        {
            "title": "Subtopic 4: Overriding `virtual` Functions",
            "slide_markdown": "## Subtopic 4: Overriding `virtual` Functions\n\n*   A derived class redefines a `virtual` method from its base class.\n*   The overriding method in the derived class must have the **same signature** (name, parameter types, const/volatile qualifiers, ref-qualifiers) as the base class virtual method.\n*   The return type must be the same or a covariant return type (for pointer/reference types).\n*   Use the **`override`** specifier in the derived class (C++11 and later) for safety:\n    *   The compiler checks if the method correctly overrides a base class virtual method.\n\n```cpp\nclass Comic : public Book {\n    // ... fields specific to Comic ...\npublic:\n    // ... constructor ...\n    // Overriding Book's virtual isHeavy method\n    bool isHeavy() const override { return length_ < 30; } // Different logic\n};\n```",
            "transcript": "When a derived class provides its own implementation for a virtual method from its base class, it's called overriding. For a method in the derived class to correctly override a base class virtual method, it must have the exact same signature. This means the same name, the same parameter types in the same order, and the same const or volatile qualifiers. The return type must also be compatible â€“ either the same or, for pointer or reference return types, a covariant return type, meaning it can return a pointer or reference to a class derived from the base method's return type. Since C++11, it's highly recommended to use the `override` specifier after the function signature in the derived class. This tells the compiler your intention is to override a base class virtual method. If no such method exists in the base class (e.g., due to a typo in the signature), the compiler will flag it as an error, which is extremely helpful for catching bugs.",
            "subtopic_id": 4,
            "subtopic_title": "`virtual` Member Functions for Dynamic Dispatch"
        },
        {
            "title": "Subtopic 4: Dynamic Dispatch in Action",
            "slide_markdown": "## Subtopic 4: Dynamic Dispatch in Action\n\nWith `isHeavy()` being virtual:\n```cpp\nComic myComic(\"Writer\", \"SuperComic\", 25, \"The Hero\"); // 25 pages\nBook* bookPtr = &myComic; \nBook& bookRef = myComic;\n\n// Now, Comic::isHeavy() is called dynamically:\nstd::cout << myComic.isHeavy();   // Calls Comic::isHeavy() directly\n                                 // Output: true (if 25 < 30)\n\nstd::cout << bookPtr->isHeavy(); // DYNAMIC DISPATCH!\n                                 // Calls Comic::isHeavy() because bookPtr points to a Comic\n                                 // Output: true\n\nstd::cout << bookRef.isHeavy();  // DYNAMIC DISPATCH!\n                                 // Calls Comic::isHeavy() because bookRef refers to a Comic\n                                 // Output: true\n```\nAll calls now correctly invoke `Comic::isHeavy()`.",
            "transcript": "Let's revisit our 'isHeavy' example, but this time with 'Book::isHeavy()' declared as virtual and 'Comic::isHeavy()' overriding it. When we create a 'Comic' object and then point a 'Book' pointer (bookPtr) or a 'Book' reference (bookRef) to it, the behavior changes significantly for calls to 'isHeavy'. Calling 'myComic.isHeavy()' directly still invokes 'Comic::isHeavy()'. But now, when we call 'bookPtr->isHeavy()' or 'bookRef.isHeavy()', dynamic dispatch kicks in. At runtime, the program sees that 'bookPtr' (or 'bookRef') actually refers to a 'Comic' object. Therefore, it calls 'Comic::isHeavy()', not 'Book::isHeavy()'. This ensures that the behavior is consistent with the actual type of the object, which is the essence of polymorphism. All these calls will now yield the result from 'Comic's implementation of 'isHeavy'.",
            "subtopic_id": 4,
            "subtopic_title": "`virtual` Member Functions for Dynamic Dispatch"
        },
        {
            "title": "Subtopic 4: Polymorphism with Collections",
            "slide_markdown": "## Subtopic 4: Polymorphism with Collections\n\nVirtual functions allow treating collections of objects of different derived types uniformly through base class pointers.\n\n```cpp\nBook* myLibrary[3];\nmyLibrary[0] = new Book(\"The Great Novel\", \"Author A\", 450);\nmyLibrary[1] = new Text(\"C++ Programming\", \"Author B\", 600, \"CS\");\nmyLibrary[2] = new Comic(\"Super Adventures\", \"Author C\", 28, \"The Hero\");\n\nfor (int i = 0; i < 3; ++i) {\n    // Assuming isHeavy() is virtual and overridden appropriately\n    if (myLibrary[i]->isHeavy()) {\n        std::cout << \"Item \" << i << \" is heavy.\" << std::endl;\n    }\n    // ... other polymorphic calls ...\n    delete myLibrary[i]; // This leads to the need for virtual destructors!\n}\n```\nEach call to `myLibrary[i]->isHeavy()` will execute the version specific to the actual object's type (`Book`, `Text`, or `Comic`).",
            "transcript": "The true power of virtual functions and dynamic dispatch shines when you work with collections of objects. Imagine you have an array of 'Book' pointers, where each pointer can point to a 'Book' object, a 'Text' object, or a 'Comic' object. If methods like 'isHeavy' are virtual, you can iterate through this array and call 'isHeavy' on each element. The correct version of 'isHeavy' â€“ whether it's from 'Book', 'Text', or 'Comic' â€“ will be automatically invoked based on the actual type of the object stored at that position in the array. This allows you to write generic code that processes a variety of related object types through a common base class interface. For example, our loop can check 'isHeavy' for each item in 'myLibrary', and the right logic will be applied for each specific type of book. The 'delete' call at the end, however, highlights an important issue we'll address next: virtual destructors.",
            "subtopic_id": 4,
            "subtopic_title": "`virtual` Member Functions for Dynamic Dispatch"
        },
        {
            "title": "Subtopic 4: Summary of Virtual Functions & Dynamic Dispatch",
            "slide_markdown": "## Subtopic 4: Summary\n\n*   **`virtual` functions** in the base class enable **dynamic dispatch** (late binding).\n*   Derived classes can **`override`** virtual functions to provide specialized behavior.\n*   Use the **`override`** specifier for safety when redefining virtual functions in derived classes.\n*   When a virtual method is called via a base class pointer or reference, the version corresponding to the **object's actual (dynamic) type** is executed at runtime.\n*   This is fundamental for achieving polymorphic behavior in C++, allowing uniform treatment of objects from different classes in an inheritance hierarchy.",
            "transcript": "To recap virtual member functions and dynamic dispatch: Declaring a function as `virtual` in a base class is the key to enabling dynamic dispatch, also known as late binding. This means the decision of which function implementation to execute is made at runtime, based on the actual type of the object. Derived classes can then `override` these virtual functions to provide their own specific implementations. It's best practice to use the `override` specifier in the derived class to ensure the compiler checks that you are indeed overriding a base class virtual method correctly. When a virtual method is called through a base class pointer or reference, the C++ runtime system ensures that the version of the method belonging to the object's actual dynamic type is invoked. This mechanism is central to polymorphism in C++, allowing for flexible and extensible object-oriented designs where different object types can respond to the same message in their own unique ways.",
            "subtopic_id": 4,
            "subtopic_title": "`virtual` Member Functions for Dynamic Dispatch"
        },
        {
            "title": "Subtopic 5: Virtual Destructors - The Problem",
            "slide_markdown": "## Subtopic 5: Virtual Destructors\n\n**Problem:** Deleting a derived object through a base class pointer when the base class destructor is **not** virtual.\n\n```cpp\nclass Base {\npublic:\n    Base() { std::cout << \"Base Ctor\\n\"; }\n    ~Base() { std::cout << \"Base Dtor\\n\"; } // Non-virtual destructor\n};\n\nclass Derived : public Base {\n    int* data_;\npublic:\n    Derived() : data_(new int[10]) { std::cout << \"Derived Ctor\\n\"; }\n    ~Derived() { delete[] data_; std::cout << \"Derived Dtor\\n\"; }\n};\n\nBase* ptr = new Derived(); // Creates Base, then Derived parts\n// Output: Base Ctor, Derived Ctor\ndelete ptr; // What happens here?\n// Output: Base Dtor ONLY!\n```\n*   Only `Base::~Base()` is called.\n*   `Derived::~Derived()` is **not** called.\n*   **Result:** Resources allocated by `Derived` (like `data_`) are leaked.",
            "transcript": "Let's now focus on a critical aspect of memory management in inheritance hierarchies: virtual destructors. Consider a scenario where you have a base class pointer pointing to a dynamically allocated derived class object. When you `delete` this object through the base class pointer, if the base class's destructor is not declared `virtual`, a serious problem occurs. Only the base class destructor will be called. The derived class's destructor will be skipped. In our example, 'Base' has a non-virtual destructor. When 'ptr', a 'Base' pointer pointing to a 'Derived' object, is deleted, only 'Base's destructor runs. 'Derived's destructor, which is responsible for freeing the memory allocated for 'data_', is never invoked. This leads to a memory leak because the resources acquired by the derived class are not properly released.",
            "subtopic_id": 5,
            "subtopic_title": "Virtual Destructors"
        },
        {
            "title": "Subtopic 5: The Solution - `virtual` Base Class Destructor",
            "slide_markdown": "## Subtopic 5: The Solution - `virtual` Base Class Destructor\n\nTo ensure proper cleanup, the base class destructor **must be declared `virtual`**.\n\n```cpp\nclass BaseV {\npublic:\n    BaseV() { std::cout << \"BaseV Ctor\\n\"; }\n    virtual ~BaseV() { std::cout << \"BaseV Dtor\\n\"; } // Virtual destructor\n};\n\nclass DerivedV : public BaseV {\n    int* data_;\npublic:\n    DerivedV() : data_(new int[10]) { std::cout << \"DerivedV Ctor\\n\"; }\n    ~DerivedV() override { delete[] data_; std::cout << \"DerivedV Dtor\\n\"; }\n};\n\nBaseV* ptrV = new DerivedV();\n// Output: BaseV Ctor, DerivedV Ctor\ndelete ptrV;\n// Output: DerivedV Dtor, THEN BaseV Dtor (Correct Order!)\n```\n*   Now, `DerivedV::~DerivedV()` is called first, then `BaseV::~BaseV()`.\n*   Resources are correctly deallocated.",
            "transcript": "The solution to the destructor problem is straightforward: declare the destructor in the base class as `virtual`. When the base class destructor is virtual, deleting a derived object through a base class pointer will correctly invoke the derived class's destructor first, followed by the base class's destructor. This is the desired order for cleanup â€“ from most specific to most general. In the 'BaseV' example, the destructor '~BaseV()' is now virtual. Consequently, when 'ptrV' (a 'BaseV' pointer to a 'DerivedV' object) is deleted, 'DerivedV's destructor is called, freeing 'data_', and then 'BaseV's destructor is called. This ensures that all resources acquired by both the derived and base parts of the object are properly released, preventing memory leaks.",
            "subtopic_id": 5,
            "subtopic_title": "Virtual Destructors"
        },
        {
            "title": "Subtopic 5: Rule for Virtual Destructors",
            "slide_markdown": "## Subtopic 5: Rule for Virtual Destructors\n\n**Golden Rule:**\n*   If a class is intended to be used as a base class (i.e., you might delete instances of derived classes through a pointer to this base class), its destructor **must be `virtual`**.\n*   This applies even if the base class destructor itself does nothing (i.e., has an empty body).\n\n**Why?**\n*   Ensures that the complete destruction sequence (derived destructor then base destructor) is followed, preventing resource leaks.\n*   It's a matter of correct polymorphic behavior for cleanup.\n\nIf a class has any other `virtual` functions, it's a strong indicator it might be used as a polymorphic base class, so its destructor should generally be `virtual` too.",
            "transcript": "There's a crucial rule of thumb regarding virtual destructors: If a class is designed or intended to be a base class in an inheritance hierarchy, and especially if you anticipate deleting objects of derived classes through a pointer of this base class type, then the base class's destructor *must* be declared `virtual`. This rule holds true even if the base class destructor itself has no specific cleanup tasks to perform (i.e., its body is empty). The act of making it virtual ensures that the C++ runtime will correctly call the derived class's destructor first, followed by the base's, when `delete` is used on a base class pointer. This is essential for proper resource deallocation and preventing leaks. Generally, if your class has any other virtual functions, it's likely intended for polymorphic use, and thus, its destructor should also be virtual as a safety measure.",
            "subtopic_id": 5,
            "subtopic_title": "Virtual Destructors"
        },
        {
            "title": "Subtopic 5: Summary of Virtual Destructors",
            "slide_markdown": "## Subtopic 5: Summary\n\n*   Deleting a derived object via a base class pointer requires the base class destructor to be **`virtual`** to ensure the derived class destructor is called.\n*   If the base destructor is not `virtual`, only the base destructor runs, leading to **resource leaks** from the derived part.\n*   With a `virtual` base destructor, the derived destructor is called first, followed by the base destructor, ensuring **proper cleanup**.\n*   **Rule:** If a class is intended to be a base class, make its destructor `virtual`.",
            "transcript": "To summarize virtual destructors: When you're managing dynamically allocated objects in an inheritance hierarchy and deleting them through base class pointers, it is absolutely essential that the base class has a virtual destructor. If the base class destructor is non-virtual, only the base destructor will be invoked upon deletion. This means the derived class's destructor is skipped, and any resources specifically managed by the derived class will be leaked. However, if the base class destructor is declared virtual, the C++ runtime ensures that the derived class's destructor is called first, followed by the base class's destructor. This correct sequence guarantees proper cleanup of all parts of the object. Therefore, the fundamental rule is: if your class is designed to be a base class, always declare its destructor as virtual.",
            "subtopic_id": 5,
            "subtopic_title": "Virtual Destructors"
        },
        {
            "title": "Subtopic 6: `final` Classes",
            "slide_markdown": "## Subtopic 6: `final` Classes and Pure Virtual Methods (Abstract Classes)\n\n**`final` Classes (C++11 and later):**\n*   A class declared as `final` cannot be used as a base class (i.e., no other class can derive from it).\n\n```cpp\nclass Shape { /* ... */ };\nclass Circle final : public Shape {\n    // Circle implementation\n    // No class can derive from Circle\n};\n\n// class SpecialCircle : public Circle {}; // COMPILE ERROR! Circle is final.\n```\n*   **Purpose:**\n    *   Design decision: indicates a class is not intended for extension.\n    *   Potential performance optimizations (compiler might devirtualize calls).",
            "transcript": "Let's now look at `final` classes and abstract classes. Starting with C++11, you can declare a class as `final`. This means that the class cannot be used as a base class; no other class can inherit from it. If you attempt to derive from a class marked `final`, the compiler will issue an error. Using `final` is primarily a design decision. It clearly communicates that a class is complete in its current form and is not intended for further specialization through inheritance. There can also be potential performance benefits, as the compiler might be able to perform optimizations like devirtualization for calls on `final` class objects, knowing that the method implementations won't be overridden further down an inheritance chain.",
            "subtopic_id": 6,
            "subtopic_title": "`final` Classes and Pure Virtual Methods (Abstract Classes)"
        },
        {
            "title": "Subtopic 6: Pure Virtual Methods & Abstract Classes",
            "slide_markdown": "## Subtopic 6: Pure Virtual Methods & Abstract Classes\n\n**Pure Virtual Method:**\n*   A virtual method in a base class for which the base class provides no implementation.\n*   Declared by appending `= 0` to its declaration.\n\n```cpp\nclass Student {\nprotected:\n    int numCourses_;\npublic:\n    Student(int nc) : numCourses_(nc) {}\n    virtual int fees() const = 0; // Pure virtual method\n    virtual ~Student() {} // Always good to have a virtual dtor for base classes\n};\n```\n\n**Abstract Class:**\n*   A class that contains at least one pure virtual method.\n*   **Cannot be instantiated directly:** `Student s(3); // COMPILE ERROR!`\n*   Purpose: To serve as an interface or a common base for a hierarchy of related classes. It defines a contract that derived concrete classes must fulfill.",
            "transcript": "A pure virtual method is a special kind of virtual method in a base class that has no implementation provided by the base class itself. It's declared by writing `= 0` at the end of its signature. For instance, in our 'Student' class, `virtual int fees() const = 0;` declares 'fees' as a pure virtual method. This signifies that the 'Student' class itself doesn't know how to calculate fees, but it mandates that any concrete derived class must provide an implementation for it.\n\nA class that contains one or more pure virtual methods is called an abstract class. The most significant characteristic of an abstract class is that you cannot create objects (instances) of it directly. If you try to instantiate an abstract class, like 'Student s(3);', you'll get a compile error. The purpose of an abstract class is typically to define an interface or a common blueprint for a family of derived classes. It establishes a contract: any non-abstract class deriving from it must implement all its pure virtual methods.",
            "subtopic_id": 6,
            "subtopic_title": "`final` Classes and Pure Virtual Methods (Abstract Classes)"
        },
        {
            "title": "Subtopic 6: Concrete Classes from Abstract Bases",
            "slide_markdown": "## Subtopic 6: Concrete Classes from Abstract Bases\n\n*   A derived class becomes **concrete** (instantiable) only if it implements (overrides) **all** pure virtual methods inherited from its abstract base class(es).\n*   If a derived class does not implement all inherited pure virtual methods, it too becomes an abstract class.\n\n```cpp\nclass Regular : public Student {\npublic:\n    Regular(int nc) : Student(nc) {}\n    int fees() const override { // Implementation provided\n        return numCourses_ * 500; \n    }\n};\nRegular regStudent(2); // OK! Regular is concrete.\n\nclass Coop : public Student {\npublic:\n    Coop(int nc) : Student(nc) {}\n    int fees() const override { // Implementation provided\n        return numCourses_ * 300;\n    }\n};\nCoop coopStudent(4); // OK! Coop is concrete.\n```",
            "transcript": "For a class derived from an abstract base class to become a concrete class (meaning you can create objects of its type), it must provide implementations for all the pure virtual methods it inherits. If it fails to implement even one of them, the derived class itself remains abstract and cannot be instantiated. In our example, both 'Regular' and 'Coop' are derived from the abstract 'Student' class. They both provide an override for the pure virtual 'fees' method. Because they fulfill this contract, 'Regular' and 'Coop' become concrete classes, and we can create objects like 'regStudent' and 'coopStudent'. If, say, 'Regular' had forgotten to implement 'fees', then 'Regular' would also be an abstract class.",
            "subtopic_id": 6,
            "subtopic_title": "`final` Classes and Pure Virtual Methods (Abstract Classes)"
        },
        {
            "title": "Subtopic 6: UML Representation",
            "slide_markdown": "## Subtopic 6: UML Representation\n\nIn UML (Unified Modeling Language) diagrams:\n*   **Abstract class names** are often written in *italics*.\n*   **Pure virtual method names** are also often written in *italics*.\n\nThis visual cue helps in understanding the design and identifying which classes are interfaces or abstract concepts versus concrete implementations.\n\nExample:\n```mermaid\nclassDiagram\n    class Student {\n        +int numCourses\n        +int fees() const*\n    }\n    Student : +fees() const = 0\n    class Regular {\n        +int fees() const\n    }\n    class Coop {\n        +int fees() const\n    }\n    Student <|-- Regular\n    Student <|-- Coop\n\n    note for Student \"Italic name implies abstract\"\n    note for Student \"fees() italic implies pure virtual\"\n```\n*(Mermaid syntax used for conceptual UML representation; actual UML tools may vary)*",
            "transcript": "In Unified Modeling Language, or UML, which is a standard way to visualize software designs, there are conventions for representing abstract classes and pure virtual methods. Typically, the names of abstract classes are written in italics. Similarly, the names of pure virtual methods within a class diagram are also often italicized. These visual cues are helpful because they immediately tell someone looking at the diagram that a particular class cannot be instantiated directly and serves as an abstract concept or interface, and that certain methods must be implemented by concrete subclasses. This aids in quickly grasping the structure and intent of an object-oriented design.",
            "subtopic_id": 6,
            "subtopic_title": "`final` Classes and Pure Virtual Methods (Abstract Classes)"
        },
        {
            "title": "Subtopic 6: Summary of `final` & Abstract Classes",
            "slide_markdown": "## Subtopic 6: Summary\n\n*   **`final` classes** cannot be inherited from, marking them as the end-point of an inheritance chain.\n*   **Pure virtual methods** (declared with `= 0`) define an interface in the base class without providing an implementation.\n*   A class with one or more pure virtual methods is an **abstract class** and **cannot be instantiated**.\n*   Derived classes must implement **all inherited pure virtual methods** to become **concrete** (instantiable).\n*   Abstract classes are fundamental for defining interfaces and common behaviors in an inheritance hierarchy.",
            "transcript": "To summarize this final subtopic: `final` classes are those that cannot be further derived, effectively sealing them off from being base classes. This is a design choice to indicate a class's completeness or for potential optimizations. Pure virtual methods, declared with an '= 0' suffix, are methods in a base class that do not have an implementation within that base class. They essentially define a contract or an interface that derived classes must fulfill. Any class containing at least one pure virtual method automatically becomes an abstract class, which means you cannot create direct instances of it. For a derived class to be instantiable (i.e., to become a concrete class), it must provide implementations for all the pure virtual methods it has inherited. Abstract classes are crucial for designing flexible and extensible systems by clearly separating interface from implementation.",
            "subtopic_id": 6,
            "subtopic_title": "`final` Classes and Pure Virtual Methods (Abstract Classes)"
        },
        {
            "title": "Lecture 14: Conclusion",
            "slide_markdown": "## Lecture 14: Conclusion\n\n**Key Takeaways:**\n*   **Inheritance** allows code reuse and modeling \"is-a\" relationships.\n    *   Constructor chaining (MIL) is crucial for proper initialization.\n    *   `protected` access offers a middle ground for derived class access.\n*   **Polymorphism** is achieved through **`virtual` functions** enabling **dynamic dispatch**.\n    *   Solves issues of static dispatch and allows objects to behave according to their actual type.\n    *   Avoids slicing when working with pointers/references.\n*   **`virtual` destructors** are essential for correct cleanup in polymorphic hierarchies.\n*   **`final` classes** prevent further derivation.\n*   **Abstract classes** (with pure virtual methods) define interfaces and cannot be instantiated.\n\nUnderstanding these concepts is fundamental to effective Object-Oriented Programming in C++.",
            "transcript": "Let's conclude Lecture 14. We've covered several foundational concepts in object-oriented programming with C++. Inheritance allows us to build new classes from existing ones, promoting code reuse and modeling 'is-a' relationships. We saw the importance of constructor chaining using the Member Initialization List for proper object setup and discussed how 'protected' access can be used to grant derived classes special privileges, ideally through accessor and mutator methods rather than direct data access. The core of polymorphism lies in virtual functions, which enable dynamic dispatch. This allows the system to decide at runtime which method to call based on an object's actual type, overcoming issues like slicing (when using pointers/references) and static dispatch that occur with non-virtual methods. We emphasized the critical need for virtual destructors in base classes to ensure correct memory deallocation when dealing with derived objects through base pointers. Finally, we looked at 'final' classes, which cannot be further inherited, and abstract classes, defined by pure virtual methods, which serve as interfaces and cannot be instantiated directly. Mastering these concepts is key to writing robust, flexible, and maintainable C++ code.",
            "subtopic_id": 99,
            "subtopic_title": "Section Conclusion"
        }
    ]
}
```