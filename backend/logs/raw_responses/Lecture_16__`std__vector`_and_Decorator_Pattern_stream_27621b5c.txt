```json
{
    "section_title": "Lecture 16: `std::vector` and Decorator Pattern",
    "section_description": "This lecture introduces `std::vector` for dynamic array management in C++ and explores the Decorator design pattern for dynamically adding responsibilities to objects.",
    "slides": [
        {
            "title": "Lecture 16: Introduction",
            "slide_markdown": "## Lecture 16: `std::vector` & Decorator Pattern\n\n**Today's Topics:**\n\n1.  **`std::vector`**: C++'s dynamic array solution.\n    *   Basic usage, iteration techniques.\n2.  **Guiding Principle for Design Patterns**: Program to Interfaces.\n3.  **Decorator Design Pattern**: \n    *   Concept and UML.\n    *   Practical example: Building customizable pizzas.",
            "transcript": "Welcome to Lecture 16. Today, we'll cover two important topics. First, we'll dive into `std::vector`, which is the standard C++ way to handle dynamic arrays, making memory management much easier. We'll look at its basic usage and how to iterate through its elements. After that, we'll discuss a fundamental guiding principle in software design: programming to interfaces, not implementations. This principle is key to creating flexible and maintainable systems. Finally, we'll explore the Decorator design pattern. We'll understand its concept, look at its UML structure, and then walk through a practical example of building customizable pizzas to see how it allows us to add features to objects dynamically at runtime.",
            "subtopic_id": 0,
            "subtopic_title": "Introduction"
        },
        {
            "title": "`std::vector`: Introduction",
            "slide_markdown": "## `std::vector`: Dynamic Length Arrays\n\n*   **What is `std::vector`?**\n    *   A sequence container representing arrays that can change in size.\n    *   Part of the C++ Standard Library, available via `#include <vector>`.\n*   **Why use `std::vector`?**\n    *   Manages its own storage (typically a dynamic array on the heap).\n    *   Handles memory allocation and deallocation automatically (RAII).\n    *   Safer and more convenient than manual `new[]`/`delete[]`.\n    *   Guaranteed to be implemented internally as a contiguous array (important for performance and C API compatibility).",
            "transcript": "Let's start with `std::vector`. A `std::vector` is a sequence container that encapsulates dynamic size arrays. This means you can have an array that grows or shrinks as needed during runtime. It's a core part of the C++ Standard Library, and you use it by including the `<vector>` header. The primary reason to use `std::vector` is for its automatic memory management. It allocates memory for its elements, typically on the heap, and will automatically deallocate this memory when the vector itself goes out of scope. This adherence to the RAII (Resource Acquisition Is Initialization) principle makes it much safer and more convenient than manually managing memory with `new[]` and `delete[]`, significantly reducing the risk of memory leaks or corruption. Furthermore, `std::vector` guarantees that its elements are stored contiguously, just like a C-style array, which is beneficial for performance and when interacting with C APIs.",
            "subtopic_id": 1,
            "subtopic_title": "`std::vector` - Dynamic Length Arrays"
        },
        {
            "title": "`std::vector`: Basic Usage",
            "slide_markdown": "## `std::vector`: Basic Usage\n\n*   **Header**: `#include <vector>`\n*   **Initialization**:\n    ```cpp\n    std::vector<int> v1; // Empty vector\n    std::vector<int> v2 = {1, 2, 3, 4, 5}; // Initializer list (C++11)\n    std::vector<int> v3(5, 100); // 5 integers, each with value 100\n    ```\n*   **Adding Elements**:\n    *   `v.push_back(value)`: Adds element to the end (C++03 style, still common).\n    *   `v.emplace_back(args...)`: Constructs element in-place at the end (C++11, often more efficient).\n    ```cpp\n    std::vector<int> v = {4, 5};\n    v.emplace_back(6); // v is now {4, 5, 6}\n    ```\n*   **Removing Last Element**:\n    *   `v.pop_back()`: Removes the last element.\n    ```cpp\n    v.pop_back(); // v is now {4, 5}\n    ```\n*   **Getting Size**:\n    *   `v.size()`: Returns the number of elements.\n    *   `v.empty()`: Returns true if the vector is empty.",
            "transcript": "To use `std::vector`, you first need to include the `<vector>` header. Vectors can be initialized in several ways. You can create an empty vector, initialize it with a list of values using an initializer list if you're using C++11 or later, or create a vector of a specific size where all elements have a certain value. To add elements, `emplace_back` is generally preferred since C++11 as it constructs the element directly in the vector's memory, which can be more efficient than `push_back` if you're creating complex objects, though for simple types like integers, the difference might be negligible. `push_back` copies or moves an existing object to the end. To remove the last element, you use `pop_back()`. This function doesn't return the removed element; it just discards it. You can get the current number of elements in the vector using the `size()` member function, and check if it's empty using `empty()`.",
            "subtopic_id": 1,
            "subtopic_title": "`std::vector` - Dynamic Length Arrays"
        },
        {
            "title": "`std::vector`: Iteration - Index & Range-based",
            "slide_markdown": "## `std::vector`: Iterating Through Elements\n\n**1. Index-based Loop (C-style):**\n```cpp\n#include <vector>\n#include <iostream>\n\nstd::vector<int> v = {10, 20, 30};\nfor (size_t i = 0; i < v.size(); ++i) {\n    std::cout << v[i] << \" \"; // Access using operator[]\n}\n// Output: 10 20 30 \n```\n*   `v.at(i)`: Accesses element with bounds checking (throws `std::out_of_range`).\n\n**2. Range-based for Loop (C++11 and later):**\n```cpp\nfor (int val : v) {\n    std::cout << val << \" \";\n}\n// Output: 10 20 30 \n\n// To modify elements:\nfor (int &val_ref : v) {\n    val_ref *= 2;\n}\n```",
            "transcript": "There are several ways to iterate through the elements of a `std::vector`. The traditional C-style index-based loop works by accessing elements using their zero-based index with the `operator[]`. It's important to use `size_t` for the loop counter to match the return type of `v.size()` and avoid potential comparison warnings. While `operator[]` provides fast access, it doesn't perform bounds checking. If you need bounds checking, you can use `v.at(i)`, which will throw a `std::out_of_range` exception if the index is invalid. Since C++11, the range-based for loop offers a more concise and often safer way to iterate. It automatically handles iterating from the beginning to the end of the vector. If you just want to read the values, you can declare the loop variable by value. If you need to modify the elements within the loop, you should declare the loop variable as a reference.",
            "subtopic_id": 1,
            "subtopic_title": "`std::vector` - Dynamic Length Arrays"
        },
        {
            "title": "`std::vector`: Iteration - Iterators",
            "slide_markdown": "## `std::vector`: Iterating with Iterators\n\n**3. Iterators:**\n   *   `v.begin()`: Returns an iterator to the first element.\n   *   `v.end()`: Returns an iterator to one past the last element.\n```cpp\n// Forward iteration\nfor (std::vector<int>::iterator it = v.begin(); it != v.end(); ++it) {\n    std::cout << *it << \" \"; // Dereference iterator to get value\n}\n// Output: 10 20 30 (assuming v is {10, 20, 30})\n\n// Using auto for iterator type (C++11)\nfor (auto it = v.begin(); it != v.end(); ++it) { /* ... */ }\n```\n\n**Reverse Iteration:**\n   *   `v.rbegin()`: Returns a reverse iterator to the last element.\n   *   `v.rend()`: Returns a reverse iterator to one before the first element.\n```cpp\nfor (std::vector<int>::reverse_iterator rit = v.rbegin(); rit != v.rend(); ++rit) {\n    std::cout << *rit << \" \";\n}\n// Output: 30 20 10 \n```",
            "transcript": "Iterators provide a more general way to traverse containers. For a `std::vector`, `v.begin()` gives an iterator pointing to the first element, and `v.end()` gives an iterator pointing to a conceptual element just after the last actual element. You loop as long as the iterator is not equal to `v.end()`, and you move to the next element using the increment operator `++it`. To get the value an iterator points to, you dereference it using `*it`. Since C++11, you can use `auto` to let the compiler deduce the iterator type, making the code cleaner. Vectors also support reverse iteration. `v.rbegin()` returns a reverse iterator pointing to what was the last element, and `v.rend()` points to a conceptual element just before what was the first. You use these similarly to forward iterators but they traverse the vector in reverse order.",
            "subtopic_id": 1,
            "subtopic_title": "`std::vector` - Dynamic Length Arrays"
        },
        {
            "title": "`std::vector`: Summary",
            "slide_markdown": "## `std::vector`: Summary\n\n*   **Dynamic Sizing**: Adapts its size automatically.\n*   **Memory Management**: Handles allocation/deallocation, reducing leaks.\n*   **Contiguous Storage**: Elements are stored side-by-side like C-arrays.\n    *   Efficient element access.\n    *   Compatible with C-style APIs expecting pointers to contiguous data (via `v.data()`).\n*   **Rich Interface**: Provides many useful member functions (e.g., `insert`, `erase`, `clear`, `resize`).\n*   **Preferred Choice**: Generally, use `std::vector` instead of manual dynamic arrays (`new[]`/`delete[]`) for better safety and convenience in C++.",
            "transcript": "To summarize `std::vector`, its key advantages are dynamic sizing, which allows it to grow or shrink as needed, and automatic memory management, which greatly simplifies resource handling and helps prevent common errors like memory leaks. The guarantee of contiguous storage means that element access is efficient, similar to C-style arrays, and you can even get a raw pointer to the underlying data using `v.data()` if you need to interface with C APIs. `std::vector` also offers a rich set of member functions for various operations like inserting or erasing elements, clearing the vector, or resizing it. Given these benefits, `std::vector` should be your default choice for dynamic arrays in C++ over manual memory management with `new[]` and `delete[]`.",
            "subtopic_id": 1,
            "subtopic_title": "`std::vector` - Dynamic Length Arrays"
        },
        {
            "title": "Design Patterns: Guiding Principle",
            "slide_markdown": "## Guiding Principle for Design Patterns: Program to Interfaces\n\n**The Core Idea:**\n\n> \"Program to an *interface*, not an *implementation*.\"\n\n*   Focus on *what* an object can do (its interface) rather than *how* it does it (its implementation).\n*   Promotes loose coupling between components.",
            "transcript": "Now, let's shift gears to design patterns. A fundamental principle that underpins many design patterns is to 'Program to an interface, not an implementation.' This means that when you're designing your software, you should focus on defining clear contracts, or interfaces, that specify what objects can do, rather than tying your code directly to concrete classes that detail how those actions are performed. This approach promotes loose coupling, making your system more flexible and easier to change.",
            "subtopic_id": 2,
            "subtopic_title": "Guiding Principle for Design Patterns: Program to Interfaces"
        },
        {
            "title": "Program to Interfaces: How It's Done",
            "slide_markdown": "## Program to Interfaces: How It's Done\n\n1.  **Define Abstract Base Classes (Interfaces)**:\n    *   Use classes with pure virtual functions to define a contract.\n    ```cpp\n    class Shape {\n    public:\n        virtual void draw() = 0; // Pure virtual function\n        virtual double area() const = 0;\n        virtual ~Shape() {} // Important: virtual destructor\n    };\n    ```\n2.  **Work with Base Class Pointers/References**:\n    *   Manipulate objects through pointers or references to the abstract base class.\n    ```cpp\n    void processShape(Shape* s) {\n        s->draw(); \n        std::cout << \"Area: \" << s->area() << std::endl;\n    }\n    ```\n3.  **Call Virtual Methods**: \n    *   Relies on polymorphism for correct method dispatch at runtime.",
            "transcript": "So, how do we actually program to an interface in C++? First, we define abstract base classes that act as our interfaces. These classes typically contain one or more pure virtual functions, which declare a contract that concrete derived classes must implement. It's also crucial for such base classes to have a virtual destructor if they are to be used polymorphically with dynamic allocation. Second, instead of working directly with concrete class types, we manipulate objects using pointers or references to the abstract base class. For example, a function might take a `Shape*` pointer. Finally, we call the virtual methods defined in the interface. Thanks to polymorphism, the correct version of the method for the actual concrete object being pointed to will be invoked at runtime.",
            "subtopic_id": 2,
            "subtopic_title": "Guiding Principle for Design Patterns: Program to Interfaces"
        },
        {
            "title": "Program to Interfaces: Benefits",
            "slide_markdown": "## Program to Interfaces: Benefits\n\n*   **Flexibility & Extensibility**:\n    *   New concrete implementations (subclasses) can be added without changing client code that uses the interface.\n    *   Concrete subclasses can be "snapped in" or interchanged.\n*   **Reduced Dependencies**:\n    *   Client code depends on the stable abstract interface, not volatile concrete classes.\n*   **Improved Testability**:\n    *   Mock objects (test doubles) implementing the interface can be easily substituted for real objects during testing.\n*   **Abstraction**: Provides a layer of abstraction over a variety of potentially complex behaviors.",
            "transcript": "Programming to interfaces offers several significant benefits. It greatly enhances flexibility and extensibility. You can introduce new types of objects (new concrete subclasses) that conform to the interface without needing to modify the existing code that uses that interface. Think of it like being able to swap out different components that all fit the same socket. This leads to reduced dependencies; your client code is coupled to the stable abstract interface, not to the specific, potentially changing, concrete implementations. This also improves testability, as you can easily create mock objects that implement the interface for use in unit tests, isolating the code you're testing from its actual dependencies. Overall, it provides a powerful abstraction mechanism, allowing you to work with a variety of behaviors through a common, simplified contract.",
            "subtopic_id": 2,
            "subtopic_title": "Guiding Principle for Design Patterns: Program to Interfaces"
        },
        {
            "title": "Program to Interfaces: Summary",
            "slide_markdown": "## Program to Interfaces: Summary\n\n*   **Key Takeaway**: Decouple parts of your system by relying on abstract contracts (interfaces) rather than concrete details.\n*   **Mechanism**: Achieved through abstract base classes, virtual functions, and using base class pointers/references.\n*   **Goal**: Create systems that are easier to maintain, extend, and test.\n*   This principle is fundamental to understanding and applying many design patterns, including the Decorator pattern we'll see next.",
            "transcript": "In summary, programming to an interface is about decoupling different parts of your system. You achieve this by having components interact through abstract contracts, or interfaces, rather than depending on the specific, concrete details of other components. In C++, this is typically realized using abstract base classes with virtual functions, and by manipulating objects through pointers or references to these base types. The ultimate goal is to build software systems that are more maintainable, extensible, and testable. This principle is a cornerstone of good object-oriented design and is essential for effectively using many design patterns, such as the Decorator pattern, which we are about to discuss.",
            "subtopic_id": 2,
            "subtopic_title": "Guiding Principle for Design Patterns: Program to Interfaces"
        },
        {
            "title": "Decorator Pattern: Introduction",
            "slide_markdown": "## Decorator Design Pattern: Introduction\n\n*   **Intent**: Attach additional responsibilities to an object dynamically.\n*   **Problem**: How to add functionality/features to individual objects at runtime, without affecting other objects of the same class?\n    *   Subclassing can lead to a large number of subclasses for all possible combinations of features.\n*   **Solution**: Decorators provide a flexible alternative to subclassing for extending functionality.\n    *   Objects are "wrapped" by one or more decorator objects.",
            "transcript": "Now, let's introduce the Decorator design pattern. The main intent of the Decorator pattern is to allow you to attach additional responsibilities or behaviors to an object dynamically, meaning at runtime. Imagine you have an object, and you want to add some new features to it, but perhaps only to this specific instance, or perhaps you want to combine features in ways that aren't known at compile time. If you were to use subclassing for every possible combination of features, you could end up with a massive explosion of subclasses, which becomes unmanageable. The Decorator pattern offers a more flexible solution by allowing you to 'wrap' an object with one or more decorator objects, each adding a piece of functionality.",
            "subtopic_id": 3,
            "subtopic_title": "Decorator Design Pattern: Concept and UML"
        },
        {
            "title": "Decorator Pattern: Motivating Example",
            "slide_markdown": "## Decorator Pattern: Motivating Example - Windowing System\n\n*   **Scenario**: A graphical windowing system.\n    *   Start with a basic `Window` object.\n*   **Enhancements needed at runtime**: \n    *   Add a scroll bar to a window.\n    *   Add a border to a window.\n    *   Add both a scroll bar AND a border.\n\n```\n+-----------------------+\n| BasicWindow           |\n+-----------------------+\n\n+-----------------------+\n| ScrollableWindow      |\n| (wraps BasicWindow)   |\n+-----------------------+\n\n+-----------------------+\n| BorderedScrollableWin |\n| (wraps ScrollableWin) |\n+-----------------------+\n```\n*   The Decorator pattern allows these features to be composed dynamically.",
            "transcript": "A classic motivating example for the Decorator pattern is a graphical windowing system. You might start with a basic window object that can display content. Then, at runtime, you might want to add a scroll bar to this window. Or perhaps you want to add a border. Or, you might want to add both a scroll bar and a border to the same window. If you tried to handle all these combinations with static inheritance, you'd have `BasicWindow`, `ScrollableWindow`, `BorderedWindow`, and `ScrollableBorderedWindow`, and so on for every new feature. The Decorator pattern allows you to achieve this by wrapping the basic window with a `ScrollDecorator`, and then perhaps wrapping that with a `BorderDecorator`, all dynamically.",
            "subtopic_id": 3,
            "subtopic_title": "Decorator Design Pattern: Concept and UML"
        },
        {
            "title": "Decorator Pattern: UML Structure - Core Participants",
            "slide_markdown": "## Decorator Pattern: UML Structure\n\n**Key Participants:**\n\n1.  **`Component`** (e.g., `Window`)\n    *   Defines the interface for objects that can have responsibilities added to them dynamically.\n    *   Example methods: `draw()`, `getDescription()`.\n\n2.  **`ConcreteComponent`** (e.g., `BasicWindow`)\n    *   Defines an object to which additional responsibilities can be attached.\n    *   Implements the `Component` interface.\n\n3.  **`Decorator`** (e.g., `WindowDecorator`)\n    *   Maintains a reference (pointer) to a `Component` object (the "wrapped" object).\n    *   Implements the `Component` interface, forwarding requests to its `Component` object.\n    *   Acts as an abstract class for concrete decorators.",
            "transcript": "Let's look at the UML structure of the Decorator pattern. There are a few key participants. First, the `Component`. This is an interface (often an abstract class in C++) that defines the common operations for both the objects being decorated and the decorators themselves. For our window example, this could be a `Window` interface with a `draw()` method. Second, the `ConcreteComponent`. This is a class that implements the `Component` interface and represents the actual object that we want to add new functionalities to. For example, a `BasicWindow`. Third, the `Decorator`. This is an abstract class that also implements the `Component` interface. Crucially, it maintains a reference or pointer to a `Component` object – this is the object it 'wraps' or 'decorates'. The Decorator typically forwards requests to this wrapped component. It serves as the base class for all concrete decorators.",
            "subtopic_id": 3,
            "subtopic_title": "Decorator Design Pattern: Concept and UML"
        },
        {
            "title": "Decorator Pattern: UML Structure - Concrete Decorators",
            "slide_markdown": "## Decorator Pattern: UML Structure (Continued)\n\n4.  **`ConcreteDecorator`** (e.g., `ScrollDecorator`, `BorderDecorator`)\n    *   Inherits from `Decorator`.\n    *   Adds specific responsibilities to the `Component` it wraps.\n    *   Overrides methods from the `Component` interface:\n        *   Can perform work before or after forwarding the request to the wrapped component.\n        *   Example: `ScrollDecorator::draw()` might call `wrappedWindow->draw()` and then draw scrollbars.\n\n**UML Diagram Snippet:**\n```mermaid\nclassDiagram\n    Component <|-- ConcreteComponent\n    Component <|-- Decorator\n    Decorator <|-- ConcreteDecoratorA\n    Decorator <|-- ConcreteDecoratorB\n    Decorator o-- Component : wraps\n\n    class Component{\n        +operation()\n    }\n    class ConcreteComponent{\n        +operation()\n    }\n    class Decorator{\n        -component: Component\n        +operation()\n    }\n    class ConcreteDecoratorA{\n        +operation()\n        +addedBehavior()\n    }\n```",
            "transcript": "Continuing with the UML structure, we have `ConcreteDecorator` classes. These are the classes that actually add the new responsibilities. They inherit from the abstract `Decorator` class. When a `ConcreteDecorator`'s method (like `draw()`) is called, it can perform its own specific operations, and then it typically delegates the call to the `draw()` method of the `Component` object it is wrapping. This delegation might happen before or after the decorator adds its own behavior. For instance, a `ScrollDecorator`'s `draw` method might first call the `draw` method of the window it's wrapping, and then draw the scrollbars on top. The diagram shows that both `ConcreteComponent` and `Decorator` implement the `Component` interface. `ConcreteDecorator`s extend `Decorator`, and the `Decorator` has a composition relationship with `Component`, indicating it wraps a component.",
            "subtopic_id": 3,
            "subtopic_title": "Decorator Design Pattern: Concept and UML"
        },
        {
            "title": "Decorator Pattern: Key Relationships & Summary",
            "slide_markdown": "## Decorator Pattern: Key Relationships & Summary\n\n*   **"Is-a" Relationship**: \n    *   A `Decorator` *is-a* `Component` (it conforms to the same interface).\n    *   This allows decorators to be used wherever a `Component` is expected.\n*   **"Has-a" Relationship**: \n    *   A `Decorator` *has-a* `Component` (it wraps another `Component` instance).\n    *   This allows decorators to be nested or chained.\n\n**Summary of Decorator Pattern:**\n*   Dynamically adds responsibilities to objects.\n*   Avoids subclass explosion for feature combinations.\n*   Decorators wrap components, both sharing a common interface.\n*   Allows for flexible composition of functionalities at runtime.",
            "transcript": "Two key relationships are central to the Decorator pattern. First, the 'is-a' relationship: a Decorator *is-a* Component because it implements the same interface. This is crucial because it means a decorated object can be used transparently in any context that expects the original Component type. Second, the 'has-a' relationship: a Decorator *has-a* Component, meaning it holds a reference to (wraps) another Component object. This wrapped object could be a ConcreteComponent or another Decorator, which allows decorators to be nested or chained together. In summary, the Decorator pattern is a structural pattern that lets you add new behaviors to objects dynamically by placing these objects inside special wrapper objects that contain the behaviors. It's a great way to avoid a large number of subclasses when you have many independent ways to extend functionality, and it promotes flexibility by allowing you to compose these functionalities at runtime.",
            "subtopic_id": 3,
            "subtopic_title": "Decorator Design Pattern: Concept and UML"
        },
        {
            "title": "Decorator Example: Pizza - Setting the Scene",
            "slide_markdown": "## Decorator Pattern Example: Pizza\n\n*   **Goal**: Create different types of pizzas with various toppings and crust modifications.\n*   **Challenge**: Avoid creating a separate class for every possible pizza combination (e.g., `PepperoniPizza`, `MushroomStuffedCrustPizza`, etc.).\n*   **Decorator Approach**: \n    1.  Start with a base pizza (`Component`).\n    2.  Wrap it with decorators for stuffed crust, toppings, etc.\n\n**We need to define:**\n*   An interface for all pizzas and pizza decorators.\n*   A concrete base pizza.\n*   An abstract decorator class.\n*   Concrete decorator classes for each type of addition.",
            "transcript": "Let's illustrate the Decorator pattern with a more concrete example: building pizzas. Our goal is to create a system where we can easily make different kinds of pizzas. A pizza can have various toppings, different types of crusts (like stuffed crust), and so on. If we tried to create a specific class for every single combination—like a `PepperoniPizza`, a `MushroomStuffedCrustPizza`, or a `PepperoniAndMushroomStuffedCrustPizza`—we'd quickly end up with an unmanageable number of classes. The Decorator pattern provides a much cleaner solution. We'll start with a base pizza, which will be our `Component`. Then, we'll wrap this base pizza with decorators for things like a stuffed crust or different toppings. To do this, we'll need to define a common interface for all pizzas and their decorators, a class for the basic pizza itself, an abstract decorator class, and then concrete decorator classes for each type of addition we want to support.",
            "subtopic_id": 4,
            "subtopic_title": "Decorator Pattern Example: Pizza"
        },
        {
            "title": "Pizza Example: `Pizza` Interface & `CrustAndSauce` Component",
            "slide_markdown": "## Pizza Example: `Pizza` Interface & `CrustAndSauce`\n\n**1. `Pizza` (Component Interface - Abstract Class):**\n```cpp\n// Pizza.h (Interface)\n#include <string>\n\nclass Pizza {\npublic:\n    virtual float price() const = 0;\n    virtual std::string desc() const = 0;\n    virtual ~Pizza() = default; // Important: virtual destructor!\n};\n```\n\n**2. `CrustAndSauce` (ConcreteComponent):**\n```cpp\n// CrustAndSauce.h\n#include \"Pizza.h\"\n\nclass CrustAndSauce : public Pizza {\npublic:\n    float price() const override { return 5.99f; }\n    std::string desc() const override { return \"Basic Pizza Dough and Sauce\"; }\n};\n```",
            "transcript": "First, we define our `Component` interface, which we'll call `Pizza`. This abstract class declares the operations common to all pizzas and decorated pizzas. Here, we have `price()` to get the cost and `desc()` to get its description. A virtual destructor is also very important in a base class intended for polymorphic use, especially if objects might be deleted via a base class pointer. Next, we define our `ConcreteComponent`, `CrustAndSauce`. This represents the most basic pizza – just the dough and sauce. It inherits from `Pizza` and provides concrete implementations for `price()` and `desc()`, returning the base price and description for a plain pizza.",
            "subtopic_id": 4,
            "subtopic_title": "Decorator Pattern Example: Pizza"
        },
        {
            "title": "Pizza Example: `PizzaDecorator` & `StuffedCrust` Decorator",
            "slide_markdown": "## Pizza Example: `PizzaDecorator` & `StuffedCrust`\n\n**3. `PizzaDecorator` (Abstract Decorator):**\n```cpp\n// PizzaDecorator.h\n#include \"Pizza.h\"\n\nclass PizzaDecorator : public Pizza {\nprotected:\n    Pizza* component; // Pointer to the wrapped Pizza\npublic:\n    PizzaDecorator(Pizza* p) : component(p) {}\n    virtual ~PizzaDecorator() {\n        delete component; // Decorator owns the component it wraps\n    }\n\n    // Default implementations forward to component (optional)\n    // float price() const override { return component->price(); }\n    // std::string desc() const override { return component->desc(); }\n};\n```\n**4. `StuffedCrust` (ConcreteDecorator):**\n```cpp\n// StuffedCrust.h\n#include \"PizzaDecorator.h\"\n\nclass StuffedCrust : public PizzaDecorator {\npublic:\n    StuffedCrust(Pizza* p) : PizzaDecorator(p) {}\n\n    float price() const override {\n        return component->price() + 2.69f;\n    }\n    std::string desc() const override {\n        return component->desc() + \" with Stuffed Crust\";\n    }\n};\n```",
            "transcript": "Now, we create the abstract `PizzaDecorator` class. It also inherits from `Pizza`, so it conforms to the same interface. Crucially, it contains a pointer to a `Pizza` object, which is the component it will wrap. The constructor takes this component as an argument. In this example, the `PizzaDecorator`'s destructor deletes the `component`. This implies that the decorator takes ownership of the component it wraps; this is a design choice and needs to be consistent. Concrete decorators will inherit from this. For example, `StuffedCrust` is a `ConcreteDecorator`. Its constructor calls the base `PizzaDecorator` constructor. Its `price()` method first gets the price of the wrapped component and then adds the cost of the stuffed crust. Similarly, its `desc()` method appends 'with Stuffed Crust' to the description of the wrapped component.",
            "subtopic_id": 4,
            "subtopic_title": "Decorator Pattern Example: Pizza"
        },
        {
            "title": "Pizza Example: `Topping` Decorator",
            "slide_markdown": "## Pizza Example: `Topping` Decorator\n\n**5. `Topping` (ConcreteDecorator):**\n```cpp\n// Topping.h\n#include \"PizzaDecorator.h\"\n#include <string>\n\nclass Topping : public PizzaDecorator {\nprivate:\n    std::string toppingName;\n    float toppingPrice;\npublic:\n    Topping(Pizza* p, const std::string& name, float price)\n        : PizzaDecorator(p), toppingName(name), toppingPrice(price) {}\n\n    float price() const override {\n        return component->price() + toppingPrice;\n    }\n    std::string desc() const override {\n        return component->desc() + \" with \" + toppingName;\n    }\n};\n```",
            "transcript": "Here's another `ConcreteDecorator`, called `Topping`. This one is a bit more general; it can represent any kind of topping. Its constructor takes the `Pizza` component to wrap, the name of the topping, and the price of the topping. Like `StuffedCrust`, its `price()` method adds the `toppingPrice` to the price of the wrapped component, and its `desc()` method appends the `toppingName` to the description of the wrapped component. This allows us to add various toppings by creating instances of this `Topping` decorator with different names and prices.",
            "subtopic_id": 4,
            "subtopic_title": "Decorator Pattern Example: Pizza"
        },
        {
            "title": "Pizza Example: Usage - Chaining Decorators",
            "slide_markdown": "## Pizza Example: Usage\n\n**Putting it all together:**\n```cpp\n#include <iostream>\n// Include Pizza.h, CrustAndSauce.h, StuffedCrust.h, Topping.h\n\nint main() {\n    Pizza* myPizza = new CrustAndSauce();\n    std::cout << myPizza->desc() << \" costs $\" << myPizza->price() << std::endl;\n    // Output: Basic Pizza Dough and Sauce costs $5.99\n\n    myPizza = new StuffedCrust(myPizza);\n    std::cout << myPizza->desc() << \" costs $\" << myPizza->price() << std::endl;\n    // Output: Basic Pizza Dough and Sauce with Stuffed Crust costs $8.68\n\n    myPizza = new Topping(myPizza, \"Pepperoni\", 1.50f);\n    std::cout << myPizza->desc() << \" costs $\" << myPizza->price() << std::endl;\n    // Output: Basic Pizza Dough and Sauce with Stuffed Crust with Pepperoni costs $10.18\n\n    myPizza = new Topping(myPizza, \"Mushrooms\", 0.75f);\n    std::cout << myPizza->desc() << \" costs $\" << myPizza->price() << std::endl;\n    // Output: ...with Pepperoni with Mushrooms costs $10.93\n\n    delete myPizza; // Crucial! Deletes all wrapped objects if destructors are chained.\n    return 0;\n}\n```",
            "transcript": "Now let's see how to use these classes. We start by creating a base pizza, a `CrustAndSauce` object. We can then print its description and price. To add a stuffed crust, we create a `StuffedCrust` decorator, passing our current `myPizza` object to its constructor. The `myPizza` pointer now points to the `StuffedCrust` object, which wraps the original `CrustAndSauce` object. When we call `desc()` or `price()` on `myPizza`, the calls are delegated through the decorators, accumulating descriptions and costs. We can continue this process, wrapping the pizza with `Topping` decorators for pepperoni and then mushrooms. Each time, `myPizza` is updated to point to the outermost decorator. Finally, it's very important to `delete myPizza`. If the `PizzaDecorator`'s destructor correctly deletes its `component`, then deleting the outermost decorator will trigger a chain of deletions, cleaning up all dynamically allocated decorator objects and the initial concrete component. This assumes the decorator takes ownership, as designed in our `PizzaDecorator`.",
            "subtopic_id": 4,
            "subtopic_title": "Decorator Pattern Example: Pizza"
        },
        {
            "title": "Pizza Example: Summary",
            "slide_markdown": "## Decorator Pattern Example: Pizza - Summary\n\n*   **Flexibility**: Easily create complex pizzas by combining decorators.\n*   **Runtime Extension**: Functionality (toppings, crusts) is added at runtime.\n*   **Open/Closed Principle**: The system is open for extension (new toppings/decorators) but closed for modification (core `Pizza` interface and existing decorators don't need to change to add new ones).\n*   **Single Responsibility**: Each decorator class has a single responsibility (e.g., adding one topping's cost and description).\n*   **Drawback**: Can lead to many small objects. Managing ownership and cleanup (destructors) is critical.",
            "transcript": "To summarize our pizza example using the Decorator pattern: it provides great flexibility in creating complex pizza objects by dynamically combining different decorators. New functionalities, like toppings or special crusts, are added at runtime. This approach aligns well with the Open/Closed Principle: our system is open for extension (we can easily add new types of toppings or other decorators) but closed for modification (the core `Pizza` interface or existing, unrelated decorators don't need to change when a new, independent decorator is added). Each decorator class tends to have a single, well-defined responsibility. A potential drawback is that it can lead to a proliferation of small objects if many decorators are used. Also, careful management of object ownership and cleanup, particularly with destructors in the decorator chain, is critical to avoid memory leaks.",
            "subtopic_id": 4,
            "subtopic_title": "Decorator Pattern Example: Pizza"
        },
        {
            "title": "Lecture 16: Conclusion",
            "slide_markdown": "## Lecture 16: Conclusion\n\n**Key Learnings:**\n\n*   **`std::vector`**: \n    *   A powerful and safe tool for dynamic arrays in C++.\n    *   Simplifies memory management compared to raw pointers.\n*   **Program to Interfaces**: \n    *   A fundamental design principle promoting flexibility and decoupling.\n*   **Decorator Pattern**: \n    *   Allows dynamic addition of responsibilities to objects.\n    *   Uses composition and a shared interface to achieve runtime flexibility.\n\n**Next Steps**: Apply these concepts to build more robust and adaptable C++ programs.",
            "transcript": "To conclude Lecture 16, we've covered some very useful C++ features and design concepts. We learned about `std::vector`, which is your go-to solution for dynamic arrays, offering safety and convenience by managing its own memory. We also discussed the crucial design principle of programming to interfaces, not implementations, which helps in building flexible and decoupled systems. Finally, we explored the Decorator pattern, a structural pattern that allows us to add functionalities to objects dynamically at runtime by wrapping them. This pattern is particularly useful when you need to avoid a combinatorial explosion of subclasses. In our next lectures and assignments, you'll have opportunities to apply these concepts to build more robust and adaptable C++ programs.",
            "subtopic_id": 0,
            "subtopic_title": "Conclusion"
        }
    ]
}
```